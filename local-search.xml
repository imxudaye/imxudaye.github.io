<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java性能调优参数标志摘要（适用于Java8+)</title>
    <link href="/2021/12/09/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%E6%A0%87%E5%BF%97%E6%91%98%E8%A6%81%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8EJava8+%EF%BC%89/"/>
    <url>/2021/12/09/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%E6%A0%87%E5%BF%97%E6%91%98%E8%A6%81%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8EJava8+%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java性能调优参数标志摘要（适用于Java8-）"><a href="#Java性能调优参数标志摘要（适用于Java8-）" class="headerlink" title="Java性能调优参数标志摘要（适用于Java8+）"></a>Java性能调优参数标志摘要（适用于Java8+）</h3><h4 id="调优JIT编译器参数标志"><a href="#调优JIT编译器参数标志" class="headerlink" title="调优JIT编译器参数标志"></a>调优JIT编译器参数标志</h4><table><thead><tr><th align="center">参数标志</th><th align="center">功能</th><th align="center">使用场景</th><th align="center"></th></tr></thead><tbody><tr><td align="center">-server</td><td align="center">选择使用server编译器</td><td align="center">适用于长时间运行，且同时要求高性能的应用</td><td align="center"></td></tr><tr><td align="center">-client</td><td align="center">选择使用client编译器</td><td align="center">适用于需要快速启动的应用</td><td align="center"></td></tr><tr><td align="center">-XX:+TieredCompilation</td><td align="center">使用tiered编译（同时选择client和server标志的特性）</td><td align="center">适用于希望取得最佳性能，同时又有足够的内存可以支撑额外的编译代码的应用</td><td align="center"></td></tr><tr><td align="center">-XX:ReservedCodeCacheSize=<MB></td><td align="center">设定JIT编译器进行代码编译的保留空间</td><td align="center">当你遭遇警示消息“你的代码缓存已用尽”时，可以使用这个标志，通常结合Tiered编译标志一起使用</td><td align="center"></td></tr><tr><td align="center">-XX:InitialCodeCacheSize=<MB></td><td align="center">用于替JIT编译器编译代码分配初始空间</td><td align="center">如果你需要为代码缓存预分配内存，可以使用该标志，不过这种情况不常发生</td><td align="center"></td></tr><tr><td align="center">-XX:CompileThreshold=<N></td><td align="center">设置一段代码或循环执行多少次之后转而进行编译</td><td align="center">使用server编译器时，调整这个标志可以让更多的方法变为编译执行，让编译更早地发生。如果你使用的不是Tiered编译，第一种情况有时就是一种优势。</td><td align="center"></td></tr><tr><td align="center">-XX:+PrintCompilation</td><td align="center">在日志中输出JIT编译器进行的操作</td><td align="center">如果你怀疑某个重要的方法没有进行编译，或者对编译器的工作流程感到好奇，都可以使用这个标志进行查看</td><td align="center"></td></tr><tr><td align="center">-XX:+CICompilerCount=<N></td><td align="center">设置JIT编译器使用的线程数</td><td align="center">使用Tiered编译标志时，如果有太多的编译线程启动（尤其是在运行了多个JVM的大型机上），通过该标志可以调节JIT线程的数目</td><td align="center"></td></tr></tbody></table><h4 id="选择GC算法的参数标志"><a href="#选择GC算法的参数标志" class="headerlink" title="选择GC算法的参数标志"></a>选择GC算法的参数标志</h4><table><thead><tr><th align="center">参数标志</th><th align="center">功能</th><th align="center">使用场景</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">-XX:+UseSerialGC</td><td align="center">选择使用简单的单线程垃圾收集算法</td><td align="center">适用于堆容量小于100m</td><td align="center">Serial垃圾收集器</td></tr><tr><td align="center">-XX:+UseParallelOldGC</td><td align="center">应用线程停顿时采用多线程进行老年代回收</td><td align="center">如果你的应用能够容忍偶尔发生的长时间停顿，而你又希望用最小的CPU消耗取得最大的吞吐量，可以考虑使用这个标志</td><td align="center">Throughput收集器</td></tr><tr><td align="center">-XX:+UseParallelGC</td><td align="center">应用线程停顿时采用多线程进行新生代空间回收</td><td align="center">与UseParallelGC标志结合使用</td><td align="center">Throughput收集器</td></tr><tr><td align="center">-XX:+UseConcMarkSweepGC</td><td align="center">使用后台多个线程以最低的停顿时间回收老年代</td><td align="center">如果你有充足的CPU资源可以运行后台线程，你的堆也相对较小，并且你不希望垃圾收集的停顿时间过长，就可以使用该标志</td><td align="center">CMS收集器</td></tr><tr><td align="center">-XX:+UseParNewGC</td><td align="center">应用线程停顿时采用多个线程回收新生代空间</td><td align="center">与ConcMarkSweepGC标志结合使用</td><td align="center">CMS收集器</td></tr><tr><td align="center">-XX:+UseG1GC</td><td align="center">应用线程停顿时，使用多个线程回收新生代空间，使用后台线程回收老年代空间，以最大程度减小停顿</td><td align="center">你有足够的CPU资源可以运行后台线程，你的堆也比较大，同时你又不希望有长时间的停顿，可以考虑使用该标志</td><td align="center">G1收集器</td></tr></tbody></table><h4 id="适用于所有GC算法的通用标志"><a href="#适用于所有GC算法的通用标志" class="headerlink" title="适用于所有GC算法的通用标志"></a>适用于所有GC算法的通用标志</h4><table><thead><tr><th align="center">标志</th><th align="center">功能</th><th align="center">使用场景</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">-Xms</td><td align="center">堆的初始大小</td><td align="center">如果堆的默认值小于要求，可使用此标志调整</td><td align="center"></td></tr><tr><td align="center">-Xmx</td><td align="center">堆的最大值</td><td align="center">如果默认的堆大小对你的应用而言过小（或者过大），可以利用该标志调整</td><td align="center"></td></tr><tr><td align="center">-XX:NewRatio</td><td align="center">新生代与老年代之间的比率</td><td align="center">增大这个值会降低分配给新生代空间的堆的比例；减小这个值可以增大分配给新生代的堆的比率。这个设置只是一个初始值；除非自适应调整被关闭了，否则这个比率会随着垃圾收集发生变化（CMS收集器是个例外，使用CMS时新生代的大小保持恒定）。随着新生代空间的减小，新生代垃圾收集的频率会增加，Full GC的频率会降低（反之亦然）</td><td align="center"></td></tr><tr><td align="center">-XX:NewSize</td><td align="center">新生代的初始大小</td><td align="center">\</td><td align="center"></td></tr><tr><td align="center">-XX:MaxNewSize</td><td align="center">新生代的最大值</td><td align="center">\</td><td align="center"></td></tr><tr><td align="center">-Xmn</td><td align="center">等同于NewSize + MaxNewSize</td><td align="center">看实际情况，如有需求可调整</td><td align="center"></td></tr><tr><td align="center">-XX:MetaspaceSize=N</td><td align="center">元空间的初始值</td><td align="center">如果你的应用使用了大量的类，你可能需要适当调整，增大默认值</td><td align="center"></td></tr><tr><td align="center">-XX:MaxMetaspaceSize=N</td><td align="center">元空间的最大值</td><td align="center">减小这个值可以限制类的元数据占用空间大小</td><td align="center"></td></tr><tr><td align="center">-XX:ParallelGCThreads=N</td><td align="center">垃圾收集器使用的线程数</td><td align="center">如果系统上同时运行了多个JVM，可以适当减小该参数值。如果JVM使用的堆非常大，又运行在一个处理能力很强的机器上，就应该适当增大这个参数值</td><td align="center"></td></tr><tr><td align="center">-verbose:gc</td><td align="center">开启基本的GC日志功能</td><td align="center">\</td><td align="center"></td></tr><tr><td align="center">-Xloggc:<path></td><td align="center">GC日志输出到文件</td><td align="center">日志落地到文件便于追踪分析</td><td align="center"></td></tr><tr><td align="center">-XX:+PrintGC</td><td align="center">开启GC的基本日志</td><td align="center">\</td><td align="center"></td></tr><tr><td align="center">-XX:+PrintGCDetails</td><td align="center">GC详细日志</td><td align="center">即使是在生产环境中，也应尽量开启该标志（GC日志的开销几乎可以忽略）</td><td align="center"></td></tr><tr><td align="center">-XX:+PrintGCTimeStamps</td><td align="center">GC日志时间戳</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">-XX:+PrintGCDateStamps</td><td align="center">GC日志日期时间戳</td><td align="center">相对于时间戳方式，这种方式的开销更大，不过可能更容易处理</td><td align="center"></td></tr><tr><td align="center">-XX:+PrintReferenceGC</td><td align="center">打印GC过程中弱引用和软引用的信息</td><td align="center">如果程序中大量使用了这种引用，开启这个标志可以了解它们对GC开销的影响</td><td align="center"></td></tr><tr><td align="center">-XX:+UseGCLogFileRotation</td><td align="center">GC日志循环功能以节省文件空间</td><td align="center">在长期持续运行的生产环境中，GC日志会消耗大量的磁盘空间。在这种情况下，你可能希望开启该标志</td><td align="center"></td></tr><tr><td align="center">-XX:NumberOfGCLogFiles=N</td><td align="center">GC日志文件循环时，你可以使用该标志设定保留多少个日志文件</td><td align="center">在长期持续运行的生产环境中，GC日志会消耗大量的磁盘空间。在这种情况下，你可能希望开启该标志</td><td align="center"></td></tr><tr><td align="center">-XX:GCLogFileSize=N</td><td align="center">日志循环时，利用该标志可以设定日志循环之前每个日志文件的大小</td><td align="center">需要长期持续运行的生产环境中GC日志会消耗大量的磁盘空间，这种情况你可能希望开启该标志</td><td align="center"></td></tr><tr><td align="center">-XX:+UseAdaptiveSizePolicy</td><td align="center">JVM根据设定的目标自适应调整堆大小</td><td align="center">如果不需要手动调整堆大小，开启这个标志</td><td align="center"></td></tr><tr><td align="center">-XX:+PrintAdaptiveSizePolicy</td><td align="center">GC日志中输出代大小调整的详细信息</td><td align="center">通过该标志我们可以了解JVM是如何工作的。使用G1收集器时，通过该标志的输出可以了解Full GC是否源于巨型对象的分配</td><td align="center"></td></tr><tr><td align="center">-XX:+PrintTenuringDistribution</td><td align="center">在GC日志中输出对象保持的信息</td><td align="center">通过对象保持的信息我们可以判断是否需要调整对象保持的标志，以及如何调整这些标志</td><td align="center"></td></tr><tr><td align="center">-XX:InitialSurvivorRatio=N</td><td align="center">设置新生代中预留给Survivor空间的大小</td><td align="center">如果“短寿”（short-lived）对象频繁地晋升到老年代，你可能需要考虑增大这个值</td><td align="center"></td></tr><tr><td align="center">-XX:MinSurvivorRatio=N</td><td align="center">设置新生代空间中用于自适应调整的Survivor空间大小</td><td align="center">减小这个值会减小Survivor空间的最大值（反之亦然）</td><td align="center"></td></tr><tr><td align="center">-XX:TargetSurvivorRatio=N</td><td align="center">JVM试图在Survivor空间保留的空闲空间</td><td align="center">增大这个值会缩减Survivor空间的大小（反之亦然）</td><td align="center"></td></tr><tr><td align="center">-XX:InitialTenuringThreshold=N</td><td align="center">VM试图在Survivor空间保持对象的GC周期数，该参数设置的是一个初始值</td><td align="center">增大这个值可以让对象在Survivor空间停留更长的时间，不过，需要注意的是，JVM也会对该参数进行调节</td><td align="center"></td></tr><tr><td align="center">-XX:MaxTenuringThreshold=N</td><td align="center">设置JVM可以将一个对象保持在Survivor空间的最大GC周期数</td><td align="center">增大这个值可以让对象在Survivor空间停留更长时间；JVM会依据这个设定值与初始阈值，对实际的晋升阈值进行调整</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="Throughput收集器参数标志"><a href="#Throughput收集器参数标志" class="headerlink" title="Throughput收集器参数标志"></a>Throughput收集器参数标志</h4><table><thead><tr><th align="center">标志</th><th align="center">功能</th><th align="center">使用场景</th></tr></thead><tbody><tr><td align="center">-XX:MaxGCPauseMillis=N</td><td align="center">为Throughput收集器设定最长停顿时间，堆的大小会依据该目标动态调整</td><td align="center">通常作为Throughput收集器调优的第一步，如果Throughput收集器计算出的默认堆大小无法达到应用的目标就会对其进行调整</td></tr><tr><td align="center">-XX:GCTimeRatio=N</td><td align="center">用于控制Throughput收集器在垃圾收集上花费多少时间（时间比例），堆的大小会依据该目标动态调整</td><td align="center">通常作为Throughput收集器调优的第一步，Throughput收集器计算出的默认堆大小如果无法达到应用的目标就会对其进行调整</td></tr><tr><td align="center">-XX:-AggressiveHeap</td><td align="center">对于配置了大量内存的机器，如果只运行单一的虚拟机，并为该虚拟机分配了大容量的堆，使用该标志可以开启一系列的优化标志</td><td align="center">不推荐使用该标志，理想的情况是尽可能地按照需要使用具体的调优标志</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="CMS收集器参数标志"><a href="#CMS收集器参数标志" class="headerlink" title="CMS收集器参数标志"></a>CMS收集器参数标志</h4><table><thead><tr><th align="center">标志</th><th align="center">功能</th><th align="center">使用场景</th></tr></thead><tbody><tr><td align="center">-XX:CMSInitiatingOccupancyFraction=N</td><td align="center">设定何时CMS收集器可以开启老年代空间的后台扫描</td><td align="center">如果CMS收集器发生并发模式失效，则应该适当减少此参数的数值</td></tr><tr><td align="center">-XX:+UseCMSInitiatingOccupancyOnly</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>垃圾收集器</tag>
      
      <tag>JVM参数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于垃圾收集器</title>
    <link href="/2020/10/09/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/2020/10/09/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><blockquote><p>现代 JVM 的类型繁多，最主流的四个垃圾收集器分别是：Serial 收集器（常用于单 CPU 环境）、Throughput（或者 Parallel）收集器、Concurrent 收集器（CMS）和 G1 收集器。</p></blockquote><h4 id="1-分代收集器"><a href="#1-分代收集器" class="headerlink" title="1.分代收集器"></a>1.分代收集器</h4><blockquote><p>“虽然实现的细节千差万别，但所有的垃圾收集器都遵循了同一个方式，即根据情况将堆划分成不同的代（Generation）。这些代被称为“老年代”（Old Generation 或 Tenured Generation）和“新生代”（Young Generation）。新生代又被进一步地划分为不同的区段，分别称为 Eden 空间和 Survivor 空间（不过 Eden 有时会被错误地用于指代整个新生代）。”</p><p>摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。” Apple Books. </p></blockquote><p>在Java程序当中，垃圾回收大部分处理的都是临时对象，这些临时对象所在的位置就是划分的新生代区域。</p><p>新生代填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍然在使用的对象会被移动到其他地方。这种操作被称为 <strong>Minor GC</strong>。</p><p>在垃圾收集器回收对象整理对象时，对象的引用地址会发生改变，因此此时需确保应用线程不再继续使用这些对象，这段停顿时间被称为 <strong>时空停顿（stop-the-world）</strong>。通常来说，这个停顿时间对应用的性能影响最大，减少时空停顿是调优的关键考量。</p><p>当对象不断从新生代移动到老年代，最终老年代被填满之后，JVM就需要找出老年代中不再使用的对象，并对他们进行回收。简单的垃圾收集算法直接停掉所有应用线程，找出不再使用的对象，进行回收及空间整理，这个过程称为 <strong>Full GC</strong> ，这会导致应用程序长时间的停顿。</p><p>针对这种情况，也诞生了一些<u>无停顿的收集器</u>，例如CMS和G1收集器，此类收集器通过复杂的算法，可以在应用程序保持运行的同时找出不再使用的对象。此类收集器被称为<strong>Concurrent收集器</strong> 或 <strong>低停顿收集器（Low Pause）</strong></p><table><thead><tr><th align="center">收集器</th><th align="center">简述</th></tr></thead><tbody><tr><td align="center">Serial收集器</td><td align="center">最简单的收集器，单线程，无论进行Minor GC 还是Full GC ，清理空间时，都会导致<u>时空停顿</u><br /><strong>-XX:+UseSerialGC</strong></td></tr><tr><td align="center">Throughput收集器（Parallel）</td><td align="center">大多数场景默认的垃圾收集器，多线程，性能明显优于serial<br /><strong>-XX:+UseParallelGC</strong></td></tr><tr><td align="center">CMS收集器</td><td align="center">Minor GC会暂停应用线程，多线程回收，算法标识<br /><strong>-XX:+UseParNewGC</strong><br />Full GC不再暂停应用线程，而是采用多线程定期对老年代扫描回收，消耗额外的CPU资源，且堆变得过度碎片化时会直接采用serial收集方式，产生时空停顿</td></tr><tr><td align="center">G1收集器</td><td align="center">设计初衷是为了尽量缩短处理超大堆（大于 4 GB）时产生的停顿<br />Minor GC处理方式同CMS，<br />老年代空间划分为不同区域，垃圾回收处理方式为复制整理，正常情况下不易产生碎片化<br />不过仍属于concurrent收集器，会额外消耗CPU资源</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>垃圾收集器</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于编译器调优</title>
    <link href="/2020/10/09/%E7%BC%96%E8%AF%91%E5%99%A8%E8%B0%83%E4%BC%98/"/>
    <url>/2020/10/09/%E7%BC%96%E8%AF%91%E5%99%A8%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h3 id="编译器调优"><a href="#编译器调优" class="headerlink" title="编译器调优"></a>编译器调优</h3><h4 id="1-编译线程"><a href="#1-编译线程" class="headerlink" title="1.编译线程"></a>1.编译线程</h4><p>​    当方法（或者循环）适合编译时，就会进入到编译队列。队列由一个或多个后台线程处理。即编译过程是异步的，这使得代码正在编译时，程序也能持续执行。</p><p><u><strong>编译队列不严格遵守先进先出的原则</strong></u>：调用计数次数越多的方法拥有更高的优先级（保证更重要部分代码优先编译），这也是导致PrintCompilation输出中的ID为乱序的另一个原因。</p><p>不同编译器默认开启编译线程数：</p><table><thead><tr><th align="center">编译器</th><th align="center">默认开启编译线程数量</th></tr></thead><tbody><tr><td align="center">client编译器</td><td align="center">1个</td></tr><tr><td align="center">server编译器</td><td align="center">2个</td></tr><tr><td align="center"><br />分层编译</td><td align="center">默认开启多个client和server线程<br />线程数依据一个略微复杂的等式而定<br />包括目标平台CPU数取双对数之后的数值</td></tr></tbody></table><p>编译器的线程数可通过参数 <code>-XX:CICompilerCount=N</code>调整</p><h4 id="2-内联"><a href="#2-内联" class="headerlink" title="2.内联"></a>2.内联</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x, y;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span>  </span>&#123; x = i; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Point p = getPoint();<br>p.setX(p.getX() * <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>对于上述setter、getter的调用，在编译过后的代码本质上执行的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Point p = getPoint();<br>p.x = p.x * <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>这就是内联。</p><p>现在的JVM通常会使用内联代码的方式执行方法，即默认开启内联。</p><blockquote><p>“方法是否内联取决于它有多热以及它的大小。JVM 依据内部计算来判定方法是否是热点（譬如，调用很频繁）；是否是热点并不直接与任何调优参数相关。如果方法因调用频繁而可以内联，那只有在它的字节码小于 325 字节时（或 -XX:MaxFreqInlineSize=N 所设定的任意值）才会内联。否则，只有方法很小时，即小于 35 字节（或 -XX:MaxInlineSize=N 所设定的任意值）时才会内联。”</p><p>摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。” </p></blockquote><h4 id="3-逃逸分析"><a href="#3-逃逸分析" class="headerlink" title="3.逃逸分析"></a>3.逃逸分析</h4><p>在开启逃逸分析（-XX:+DoEscapeAnalysis，默认为 true）的情况下，server编译器会执行一些非常激进的优化措施。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factorial</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> BigInteger factorial;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> BigInteger <span class="hljs-title">getFactorial</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (factorial == <span class="hljs-keyword">null</span>)<br>            factorial = ...;<br>        <span class="hljs-keyword">return</span> factorial;<br>    &#125;<br>&#125;<br><br>ArrayList&lt;BigInteger&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;BigInteger&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    Factorial factorial = <span class="hljs-keyword">new</span> Factorial(i);<br>    list.add(factorial.getFactorial());<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上述代码中，factorial 对象只在循环中引用；没有任何其他代码可以访问该对象。因此，JVM 会毫不犹豫地对这个对象进行一系列优化。</p><ul><li><input disabled="" type="checkbox"> 当调用 getFactorial() 时，没必要获得同步锁。</li><li><input disabled="" type="checkbox"> 没必要在内存中保存 n；可以在寄存器中保存该值。同样，factorial 也可以保存在寄存器中。</li><li><input disabled="" type="checkbox"> 事实上，根本就不需要分配实际的 factorial 对象；可以只追踪这个对象的个别字段。</li></ul><blockquote><p>“此类优化非常复杂：虽然这个例子非常简单，但此类优化可能会伴随更复杂的代码。由于所用的代码不同，并不是所有的优化都有必要使用。但逃逸分析可以决定哪些优化是可能的，并决定编译后的代码中哪些是必要的改变。</p><p>逃逸分析默认开启。极少数情况下，它会出错，在此类情况下关闭它会变得更快或更稳定。如果你发现了这种情况，最好的应对行为就是简化相关代码：代码越简单越好。（不过如果是 bug，则应该发送报告。）”</p><p>摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于数据序列化的小结</title>
    <link href="/2020/06/09/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%B0%8F%E7%BB%93/"/>
    <url>/2020/06/09/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="关于数据序列化的小结"><a href="#关于数据序列化的小结" class="headerlink" title="关于数据序列化的小结"></a>关于数据序列化的小结</h3><p>不同系统间的数据交换可以通过基于文本的例如XML、JSON等，而在Java进程间的交换数据，通常就是通过序列化，本文为序列化相关优化总结。</p><blockquote><p>“JDK 提供了默认的序列化对象机制，以实现 Serializable 或 Externalizable 接口。实际上，默认序列化的性能还有提升的空间，但此时进行过早的优化的确不太明智。特定的序列化和反序列化代码需要很多时间编写，而且也比默认的序列化代码更难维护。编写正确的序列化代码会有一些棘手，试图优化代码也会增加出错的风险。”</p><p>摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。”  </p></blockquote><h4 id="1-transient字段"><a href="#1-transient字段" class="headerlink" title="1.transient字段"></a>1.transient字段</h4><p>​    一般情况下，对象内属性越少，序列化的性能改进代价就越小。将字段标记为transient，默认该字段就不会序列化了。</p><blockquote><p>文中代码皆引自《Java性能权威指南》</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StockPriceHistoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StockPriceHistory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String symbol;<br>    <span class="hljs-keyword">protected</span> SortedMap&lt;Date, StockPrice&gt; prices = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>    <span class="hljs-keyword">protected</span> Date firstDate;<br>    <span class="hljs-keyword">protected</span> Date lastDate;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> needsCalc = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">protected</span> BigDecimal highPrice;<br>    <span class="hljs-keyword">protected</span> BigDecimal lowPrice;<br>    <span class="hljs-keyword">protected</span> BigDecimal averagePrice;<br>    <span class="hljs-keyword">protected</span> BigDecimal stdDev;<br>    <span class="hljs-keyword">private</span> Map&lt;BigDecimal, ArrayList&lt;Date&gt;&gt; histogram;<br>    ....<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StockPriceHistoryImpl</span><span class="hljs-params">(String s, Date firstDate, Date lastDate)</span> </span>&#123;<br>        prices = ....<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    在上述代码当中，存在着一种延迟加载的情况，当构造此StockPriceHistoryImpl对象时，会创建类型为SortedMap的对象prices，而当调用字段的getter方法时 才会去计算该字段的实际值（lazy）,此类情况下，在满足业务需求的前提下，就可以给延迟加载的字段增加 transient标记 ，优化性能。</p><h4 id="2-覆盖默认的序列化"><a href="#2-覆盖默认的序列化" class="headerlink" title="2.覆盖默认的序列化"></a>2.覆盖默认的序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> y;<br>    ....<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(ObjectOutputStream oos)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        oos.defaultWriteObject();<br>        oos.writeInt(x);<br>        oos.writeInt(y);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(ObjectInputStream ois)</span></span><br><span class="hljs-function">                                <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        ois.defaultReadObject();<br>        x = ois.readInt();<br>        y = ois.readInt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>以上代码中的writeObject为序列化时调用 ， readObject为反序列化时调用</p></blockquote><p>针对不同场景，可以考虑重写方法体覆盖对应调用，以优化序列化/反序列化性能。</p><h4 id="3-压缩序列化数据"><a href="#3-压缩序列化数据" class="headerlink" title="3.压缩序列化数据"></a>3.压缩序列化数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StockPriceHistoryCompress</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">StockPriceHistory</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] zippedPrices;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> SortedMap&lt;Date, StockPrice&gt; prices;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(ObjectOutputStream out)</span></span><br><span class="hljs-function">                <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (zippedPrices == <span class="hljs-keyword">null</span>) &#123;<br>            makeZippedPrices();<br>        &#125;<br>        out.defaultWriteObject();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(ObjectInputStream in)</span></span><br><span class="hljs-function">                <span class="hljs-keyword">throws</span> IOException,  ClassNotFoundException </span>&#123;<br>        in.defaultReadObject();<br>        unzipPrices();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeZippedPrices</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        GZIPOutputStream zip = <span class="hljs-keyword">new</span> GZIPOutputStream(baos);<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<br>                <span class="hljs-keyword">new</span> BufferedOutputStream(zip));<br>        oos.writeObject(prices);<br>        oos.close();<br>        zip.close();<br>        zippedPrices = baos.toByteArray();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unzipPrices</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        ByteArrayInputStream bais = <span class="hljs-keyword">new</span> ByteArrayInputStream(zippedPrices);<br>        GZIPInputStream zip = <span class="hljs-keyword">new</span> GZIPInputStream(bais);<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<br>                <span class="hljs-keyword">new</span> BufferedInputStream(zip));<br>        prices = (SortedMap&lt;Date, StockPrice&gt;) ois.readObject();<br>        ois.close();<br>        zip.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码中示例，在数据序列化之后进行压缩处理，使得在网络中传输更快，以达到性能优化效果。</p><h4 id="4-追踪对象复制"><a href="#4-追踪对象复制" class="headerlink" title="4.追踪对象复制"></a>4.追踪对象复制</h4><p>![image-20211206150055240](/Users/xuxiuhong/Library/Application Support/typora-user-images/image-20211206150055240.png)</p><blockquote><p>上图是一个简化版本的 map。JVM 默认先序列化 Node A 的原生数据字段，然后递归调用 Node B 的 writeObject()（接着是 Node C）。Node B 也会序列化它自己的原生数据字段，然后递归序列化它上级 Node 的字段。</p><p>但是请注意——Node B 上级节点 Node A 已经被序列化，怎么办？对象序列化的代码很智能：它会意识到这一点，并且不会再次序列化 Node A 的数据。相反，它只会在先前序列化的数据中添加一个对象引用。</p><p>追踪上一级对象从而递归所有对象，会对序列化的性能有少许影响。但正如 Point 数组的例子所示，这是无法避免的：必须追踪上一级序列化的对象以便正确恢复对象引用。不过，可以通过压缩对象引用来进行智能优化，从而在对象反序列化时易于重建。</p><p>不同的集类处理这个问题的方式有所不同。比如 TreeMap，它只是遍历树然后序列化键值，丢弃了键之间的所有关系（也就是它们的排列顺序）。在反序列化时，readObject() 会重新排列数据并生成树。虽然排序对象听起来代价很昂贵，但实际并非如此：对 10 000 只股票而言，整个过程要比默认的序列化快 20%，默认机制需要追踪所有的对象引用。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES 操作简单总结</title>
    <link href="/2020/05/26/ES%20%E6%93%8D%E4%BD%9C%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/05/26/ES%20%E6%93%8D%E4%BD%9C%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="ES-操作简单总结"><a href="#ES-操作简单总结" class="headerlink" title="ES 操作简单总结"></a>ES 操作简单总结</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一 简述"></a>一 简述</h2><blockquote><p>此篇总结基于在当前最新版本(7.15.2)</p><p>ES的result API 分为不同的请求类型对应不同操作</p></blockquote><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>​    /index_name 创建/修改索引</p><p>​    /index_name/_doc/{id} 创建文档  —创建不指定id,则默认随机</p><p>POST</p><p>​    /index_name/_doc/{id} 创建/修改文档</p><p>DELETE </p><p>​    删除索引或者文档</p><p>GET</p><p>​    查询/获取文档(指定id)</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WireGuard 服务建记录</title>
    <link href="/2019/08/11/WireGuard%20%E6%9C%8D%E5%8A%A1%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/08/11/WireGuard%20%E6%9C%8D%E5%8A%A1%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="WireGuard-服务建记录"><a href="#WireGuard-服务建记录" class="headerlink" title="WireGuard 服务建记录"></a>WireGuard 服务建记录</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">系统<span class="hljs-symbol">:Debian</span> <span class="hljs-number">10</span><br>默认内核<span class="hljs-symbol">:linux-headers-</span><span class="hljs-number">4.19</span>.0<span class="hljs-number">-14</span>-amd64<br></code></pre></td></tr></table></figure><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看当前内核版本</span><br>uname -r<br><span class="hljs-meta">#</span><span class="bash"> 安装过程需要的软件包(已装跳过)</span><br>sudo apt update<br>sudo apt install apt-transport-https vim -y<br><span class="hljs-meta">#</span><span class="bash"> 搜索内核</span><br>sudo apt search linux-image<br><span class="hljs-meta">#</span><span class="bash"> 安装5.10</span><br>sudo apt-get install linux-image-5.10.0-0.bpo.9-amd64<br><span class="hljs-meta">#</span><span class="bash"> 卸载原来的内核</span><br>sudo apt-get remove linux-headers-4.19.0-14-amd64<br><span class="hljs-meta">#</span><span class="bash"> 重启</span><br>sudo reboot<br></code></pre></td></tr></table></figure><h2 id="安装WireGuard服务端"><a href="#安装WireGuard服务端" class="headerlink" title="安装WireGuard服务端"></a>安装WireGuard服务端</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 添加backports 源</span><br>sudo sh -c &quot;echo &#x27;deb https://deb.debian.org/debian buster-backports main contrib non-free&#x27; &gt; /etc/apt/sources.list.d/buster-backports.list&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 安装软件包</span><br>sudo apt update<br>sudo apt -t buster-backports install wireguard -y<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 配置服务端</span><br>cd /etc/wireguard<br>umask 077<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 生成配置需要的密钥和公钥</span></span><br>wg genkey | tee privatekey | wg pubkey &gt; publickey<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 编辑服务端配置文件 ， 内容如下</span></span><br>sudo vim /etc/wireguard/wg0.conf<br><br></code></pre></td></tr></table></figure><h3 id="服务端配置文件内容"><a href="#服务端配置文件内容" class="headerlink" title="服务端配置文件内容"></a>服务端配置文件内容</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Interface]</span><br><span class="hljs-comment"># wireguard 内网服务器地址</span><br><span class="hljs-attr">Address</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">5.1</span>/<span class="hljs-number">32</span><br><span class="hljs-attr">SaveConfig</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">PostUp</span> = iptables -A FORWARD -i wg0 -j ACCEPT<span class="hljs-comment">; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="hljs-attr">PostDown</span> = iptables -D FORWARD -i wg0 -j ACCEPT<span class="hljs-comment">; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="hljs-comment"># wireguard 监听端口</span><br><span class="hljs-attr">ListenPort</span> = <span class="hljs-number">12345</span> <br><span class="hljs-comment"># wireguard 生成的服务端密钥</span><br><span class="hljs-attr">PrivateKey</span> = KDGU6q5EG2Pv1ayJHIqAlmG2hGklF9fJ0ZGCp09GJXk=<br></code></pre></td></tr></table></figure><h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ufw allow 12345/udp<br></code></pre></td></tr></table></figure><h3 id="服务启停"><a href="#服务启停" class="headerlink" title="服务启停"></a>服务启停</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable wg-quick@wg0<br><br>sudo systemctl start wg-quick@wg0<br><br>sudo systemctl status wg-quick@wg0<br><br>sudo systemctl stop wg-quick@wg0<br></code></pre></td></tr></table></figure><h3 id="启动成功后查看"><a href="#启动成功后查看" class="headerlink" title="启动成功后查看"></a>启动成功后查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo wg<br><br>sudo ip a show wg0<br></code></pre></td></tr></table></figure><h2 id="客户端安装（Debian）"><a href="#客户端安装（Debian）" class="headerlink" title="客户端安装（Debian）"></a>客户端安装（Debian）</h2><h3 id="wireguard安装"><a href="#wireguard安装" class="headerlink" title="wireguard安装"></a>wireguard安装</h3><p>​        等同服务端软件包安装    </p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Interface]</span><br><span class="hljs-attr">PrivateKey</span> = 客户端私钥<br><span class="hljs-attr">Address</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">5.2</span>/<span class="hljs-number">32</span><br><span class="hljs-attr">DNS</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">5.1</span><br> <br><span class="hljs-section">[Peer]</span><br><span class="hljs-attr">PublicKey</span> = 服务端公钥<br><span class="hljs-attr">AllowedIPs</span> = <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">0</span><br><span class="hljs-attr">Endpoint</span> = 服务端外网ip:服务端配置监听端口<br><br></code></pre></td></tr></table></figure><h3 id="增加服务端配置"><a href="#增加服务端配置" class="headerlink" title="增加服务端配置"></a>增加服务端配置</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Peer]</span><br><span class="hljs-attr">PublicKey</span> = 客户端公钥<br><span class="hljs-attr">AllowedIPs</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">5.2</span>/<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><h2 id="Enjoy～"><a href="#Enjoy～" class="headerlink" title="Enjoy～"></a>Enjoy～</h2>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>WireGuard</tag>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次关于Java8中的Stream测验</title>
    <link href="/2019/03/19/%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8EJava8%E4%B8%AD%E7%9A%84Stream%E6%B5%8B%E9%AA%8C/"/>
    <url>/2019/03/19/%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8EJava8%E4%B8%AD%E7%9A%84Stream%E6%B5%8B%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="一次关于Java8中的Stream测验"><a href="#一次关于Java8中的Stream测验" class="headerlink" title="一次关于Java8中的Stream测验"></a>一次关于Java8中的Stream测验</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><blockquote><p>​    在业务代码当中，常常会有多个List或者Map之间的交集差集并集需求，在Java8流式stream出现之前，往往都是以嵌套循环达到目的。此文记录测试在不同写法之间，在串行流与并行流操作之间的性能差异</p></blockquote><p><strong>先上代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义对象</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>&#125;<br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化两个size为10万的对象集合</span><br><span class="hljs-keyword">int</span> num = <span class="hljs-number">100000</span>;<br><span class="hljs-comment">//男士集合</span><br>List&lt;Student&gt; manList = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;()&#123;&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>    add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;旺财&quot;</span>+ ((<span class="hljs-keyword">int</span>) (Math.random() * num)), <span class="hljs-string">&quot;男&quot;</span>+i));<br>  &#125;<br>&#125;&#125;;<br><span class="hljs-comment">//女士集合</span><br>List&lt;Student&gt; womanList = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;()&#123;&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>    add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;旺财&quot;</span>+ ((<span class="hljs-keyword">int</span>) (Math.random() * num)), <span class="hljs-string">&quot;女&quot;</span>+i));<br>  &#125;<br>&#125;&#125;;<br></code></pre></td></tr></table></figure><h3 id="测试需求"><a href="#测试需求" class="headerlink" title="测试需求"></a>测试需求</h3><blockquote><p> 查找出有与男同学同名的所有女同学</p></blockquote><h4 id="–-非嵌套分步写法"><a href="#–-非嵌套分步写法" class="headerlink" title="– 非嵌套分步写法"></a>– 非嵌套分步写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 第一步 把男士集合名字提取出来</span><br>List&lt;String&gt; manNameList=manList.stream().map(Dog::getName).collect(Collectors.toList());<br><span class="hljs-comment">// 第二步 采用filter过滤名称重复</span><br>List&lt;Student&gt; result <br>  = womanList.stream().filter(s -&gt; manNameList.contains(s.getName())).collect(Collectors.toList());<br><br></code></pre></td></tr></table></figure><h4 id="–-错误嵌套写法"><a href="#–-错误嵌套写法" class="headerlink" title="– 错误嵌套写法"></a>– 错误嵌套写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Student&gt; result = womanList.stream().filter( s -&gt; !(manList.stream().map(Student::getName).collect(Collectors.toList())).contains(s.getName())).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h4 id="–-正确嵌套写法"><a href="#–-正确嵌套写法" class="headerlink" title="– 正确嵌套写法"></a>– 正确嵌套写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Student&gt; result = womanList.stream().filter(s -&gt; manList.stream().filter(f -&gt; f.getName().equals(s.getName())).findAny().isPresent()).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">// 初始化两个size为10万的对象集合</span><br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">100000</span>;<br>       <span class="hljs-comment">//男士集合</span><br>        List&lt;Student&gt; manList = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;()&#123;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>                add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;旺财&quot;</span>+((<span class="hljs-keyword">int</span>) (Math.random() * num) <span class="hljs-string">&quot;男&quot;</span>+i));<br>            &#125;<br>        &#125;&#125;;<br>       <span class="hljs-comment">//女士集合</span><br>        List&lt;Student&gt; womanList = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;()&#123;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>                add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;旺财&quot;</span>+ ((<span class="hljs-keyword">int</span>) (Math.random() * num)), <span class="hljs-string">&quot;女&quot;</span>+i));<br>            &#125;<br>        &#125;&#125;;<br><br>        <span class="hljs-comment">//非嵌套流式分步写法</span><br>        <span class="hljs-keyword">long</span> l = System.currentTimeMillis();<br>        <span class="hljs-comment">// 第一步 把男士集合名字提取出来</span><br>        List&lt;String&gt; manNameList=manList.stream().map(Student::getName).collect(Collectors.toList());<br>       <span class="hljs-comment">// 第二步 采用filter过滤名称重复</span><br>        List&lt;Student&gt; result<br>                = womanList.stream().filter(s -&gt; manNameList.contains(s.getName())).collect(Collectors.toList());<br>        <span class="hljs-keyword">long</span> l2 = System.currentTimeMillis();<br>        System.out.println(String.format(<span class="hljs-string">&quot;非嵌套流式分步写法 结果：%s  完成time : %s &quot;</span> , result.size(),  (l2-l)));<br><br>       <span class="hljs-comment">//错误嵌套流式迭代</span><br>        List&lt;Student&gt; stuList11 = womanList<br>                .stream()<br>                   .filter( s -&gt; !(manList.stream().map(Student::getName).collect(Collectors.toList())).contains(s.getName()))<br>                       .collect(Collectors.toList());<br>        <span class="hljs-keyword">long</span> l3 = System.currentTimeMillis();<br>        System.out.println(String.format(<span class="hljs-string">&quot;错误嵌套流式迭代 结果：%s  完成time : %s &quot;</span> , stuList11.size(),  (l3-l2)));<br><br><br>        <span class="hljs-comment">//正确嵌套流式迭代</span><br>        List&lt;Student&gt; stuList2 = womanList.stream().filter( s -&gt; !manList.stream().filter(f -&gt; f.getName().equals(s.getName())).findAny().isPresent()).collect(Collectors.toList());<br>        <span class="hljs-keyword">long</span> l4 = System.currentTimeMillis();<br>        System.out.println(String.format(<span class="hljs-string">&quot;正确嵌套流式迭代 结果：%s  完成time : %s &quot;</span> , stuList2.size(),  (l4-l3)));<br><br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><h4 id="串行流执行结果"><a href="#串行流执行结果" class="headerlink" title="串行流执行结果"></a>串行流执行结果</h4><table><thead><tr><th align="center">执行方式</th><th align="center">执行结果（数量）</th><th align="center">执行时间 （毫秒）</th></tr></thead><tbody><tr><td align="center">分步拆分写法</td><td align="center">36726</td><td align="center">56865</td></tr><tr><td align="center">错误嵌套写法</td><td align="center">36726</td><td align="center">175816</td></tr><tr><td align="center">正确嵌套写法</td><td align="center">36726</td><td align="center">93490</td></tr></tbody></table><h4 id="并行流执行结果"><a href="#并行流执行结果" class="headerlink" title="并行流执行结果"></a>并行流执行结果</h4><table><thead><tr><th align="center">执行方式</th><th align="center">执行结果（数量）</th><th align="center">执行时间 （毫秒）</th></tr></thead><tbody><tr><td align="center">分步拆分写法</td><td align="center">37041</td><td align="center">16105</td></tr><tr><td align="center">错误嵌套写法</td><td align="center">37041</td><td align="center">66748</td></tr><tr><td align="center">正确嵌套写法</td><td align="center">37041</td><td align="center">35042</td></tr></tbody></table><h4 id="结果综述："><a href="#结果综述：" class="headerlink" title="结果综述："></a>结果综述：</h4><p>​    可以看到</p><p>​        执行性能上</p><ol><li>非嵌套的流式是要明显好于嵌套写法的</li><li>盲目的嵌套写法带来的额外性能消耗是巨大的，代码习惯需注意  ⚠️</li><li>并行流操作在性能上是远远大于串行流操作的</li></ol><p>注：由于并行流使用多线程，则一切线程安全问题都应该是需要考虑的问题，如：资源竞争、死锁、事务、可见性等等</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Stream</tag>
      
      <tag>Java</tag>
      
      <tag>流式迭代</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自建windows激活服务器</title>
    <link href="/2018/09/26/%E8%87%AA%E5%BB%BAwindows%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2018/09/26/%E8%87%AA%E5%BB%BAwindows%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="自建windows激活服务器"><a href="#自建windows激活服务器" class="headerlink" title="自建windows激活服务器"></a>自建windows激活服务器</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>Windows系统中能够通过KMS进行激活的一般称为VL版,即VOLUME授权版。我们可以自行搭建KMS激活服务器，实现每180天一次的自动激活，使得系统一直保持激活状态。这次就跟大家分享一下如何利用Docker搭建KMS服务器，并演示如何利用我们自己的KMS服务器激活Windows操作系统与Microsoft Office。</p></blockquote><h4 id="KMS搭建操作步骤"><a href="#KMS搭建操作步骤" class="headerlink" title="KMS搭建操作步骤"></a>KMS搭建操作步骤</h4><ol><li><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull luodaoyi/kms-server<br></code></pre></td></tr></table></figure></li><li><p>创建启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -itd -p 1688:1688 --name kms luodaoyi/kms-server<br></code></pre></td></tr></table></figure></li><li><p>防火墙开放端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=1688/tcp --permanent<br></code></pre></td></tr></table></figure></li></ol><h4 id="激活步骤"><a href="#激活步骤" class="headerlink" title="激活步骤"></a>激活步骤</h4><h5 id="–激活windows"><a href="#–激活windows" class="headerlink" title="–激活windows"></a>–激活windows</h5><ol><li><p>先确认系统版本，<code>设置-系统-关于</code>  或者命令窗口执行 <code>wmic os get caption</code></p></li><li><p>打开 <strong><a href="https://url.zeruns.tech/kms_key">https://url.zeruns.tech/kms_key</a></strong>  ，查找获取对应版本的key， 例如：<strong>NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J</strong></p></li><li><p>管理员身份打开命令窗口，依次执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ip:port为你部署的KMS服务地址 ， 例如123.123.123.123:1688</span><br>slmgr /skms ip:port <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> key为对应版本的key</span><br>slmgr /ipk NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自动激活操作</span><br>slmgr /ato<br></code></pre></td></tr></table></figure></li></ol><h5 id="–激活Microsoft-Office"><a href="#–激活Microsoft-Office" class="headerlink" title="–激活Microsoft Office"></a>–激活Microsoft Office</h5><p>首先先确认下我们的Office是否为VOL版，方法如下：</p><p>​    <strong>管理员身份运行命令提示符，输入 <code>cd C:\Program Files\Microsoft Office\Office16</code> 切换目录 （这里请根据您自己的Office版本更改相应路径），再输入 <code>cscript ospp.vbs /dstatus</code> 。可以看到这里有VL字样即为VOL版</strong></p><p>开始激活：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">这是默认安装目录，如果有自定义目录请酌情调整</span><br>cd C:\Program Files\Microsoft Office\Office16<br><br>cscript ospp.vbs /sethst:nas.zeruns.tech<br><br>cscript ospp.vbs /act<br><span class="hljs-meta">#</span><span class="bash">最后看到Product activation successful字样即为激活成功</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>KMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux设置swap</title>
    <link href="/2018/05/26/Linux%E8%AE%BE%E7%BD%AEswap/"/>
    <url>/2018/05/26/Linux%E8%AE%BE%E7%BD%AEswap/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux设置swap"><a href="#Linux设置swap" class="headerlink" title="Linux设置swap"></a>Linux设置swap</h1><h2 id="1、创建一个-文件作为swap区"><a href="#1、创建一个-文件作为swap区" class="headerlink" title="1、创建一个 文件作为swap区"></a>1、创建一个 文件作为swap区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 名字为/swapfile1  大小为bs*count = 1024*2000000=2G，count代表的是大小，这里是2G</span><br>dd if=/dev/zero of=/swapfile1 bs=1024 count=2000000<br><br></code></pre></td></tr></table></figure><h2 id="2、将其转化为swap文件"><a href="#2、将其转化为swap文件" class="headerlink" title="2、将其转化为swap文件"></a>2、将其转化为swap文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkswap /swapfile1<br></code></pre></td></tr></table></figure><h2 id="3、将其改为只有root权限才能修改"><a href="#3、将其改为只有root权限才能修改" class="headerlink" title="3、将其改为只有root权限才能修改"></a>3、将其改为只有root权限才能修改</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> chown root:root /swapfile1</span><br><span class="hljs-meta">#</span><span class="bash"> chmod 0600 /swapfile1</span><br></code></pre></td></tr></table></figure><h2 id="4、将其激活"><a href="#4、将其激活" class="headerlink" title="4、将其激活"></a>4、将其激活</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">swapon /swapfile1<br></code></pre></td></tr></table></figure><h2 id="5、如果想要系统重启后生效，可以打开-etc-fstab在最后面加上一行"><a href="#5、如果想要系统重启后生效，可以打开-etc-fstab在最后面加上一行" class="headerlink" title="5、如果想要系统重启后生效，可以打开/etc/fstab在最后面加上一行"></a>5、如果想要系统重启后生效，可以打开/etc/fstab在最后面加上一行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano /etc/fstab<br><br>/swapfile1 swap swap defaults 0 0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>swap</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
