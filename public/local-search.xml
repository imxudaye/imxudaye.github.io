<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于垃圾收集器</title>
    <link href="/2020/10/09/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/2020/10/09/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><blockquote><p>现代 JVM 的类型繁多，最主流的四个垃圾收集器分别是：Serial 收集器（常用于单 CPU 环境）、Throughput（或者 Parallel）收集器、Concurrent 收集器（CMS）和 G1 收集器。</p></blockquote><h4 id="1-分代收集器"><a href="#1-分代收集器" class="headerlink" title="1.分代收集器"></a>1.分代收集器</h4><blockquote><p>“虽然实现的细节千差万别，但所有的垃圾收集器都遵循了同一个方式，即根据情况将堆划分成不同的代（Generation）。这些代被称为“老年代”（Old Generation 或 Tenured Generation）和“新生代”（Young Generation）。新生代又被进一步地划分为不同的区段，分别称为 Eden 空间和 Survivor 空间（不过 Eden 有时会被错误地用于指代整个新生代）。”</p><p>摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。” Apple Books. </p></blockquote><p>在Java程序当中，垃圾回收大部分处理的都是临时对象，这些临时对象所在的位置就是划分的新生代区域。</p><p>新生代填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍然在使用的对象会被移动到其他地方。这种操作被称为 <strong>Minor GC</strong>。</p><p>在垃圾收集器回收对象整理对象时，对象的引用地址会发生改变，因此此时需确保应用线程不再继续使用这些对象，这段停顿时间被称为 <strong>时空停顿（stop-the-world）</strong>。通常来说，这个停顿时间对应用的性能影响最大，减少时空停顿是调优的关键考量。</p><p>当对象不断从新生代移动到老年代，最终老年代被填满之后，JVM就需要找出老年代中不再使用的对象，并对他们进行回收。简单的垃圾收集算法直接停掉所有应用线程，找出不再使用的对象，进行回收及空间整理，这个过程称为 <strong>Full GC</strong> ，这会导致应用程序长时间的停顿。</p><p>针对这种情况，也诞生了一些<u>无停顿的收集器</u>，例如CMS和G1收集器，此类收集器通过复杂的算法，可以在应用程序保持运行的同时找出不再使用的对象。此类收集器被称为<strong>Concurrent收集器</strong> 或 <strong>低停顿收集器（Low Pause）</strong></p><table><thead><tr><th align="center">收集器</th><th align="center">简述</th></tr></thead><tbody><tr><td align="center">Serial收集器</td><td align="center">最简单的收集器，单线程，无论进行Minor GC 还是Full GC ，清理空间时，都会导致<u>时空停顿</u><br /><strong>-XX:+UseSerialGC</strong></td></tr><tr><td align="center">Throughput收集器（Parallel）</td><td align="center">大多数场景默认的垃圾收集器，多线程，性能明显优于serial<br /><strong>-XX:+UseParallelGC</strong></td></tr><tr><td align="center">CMS收集器</td><td align="center">Minor GC会暂停应用线程，多线程回收，算法标识<br /><strong>-XX:+UseParNewGC</strong><br />Full GC不再暂停应用线程，而是采用多线程定期对老年代扫描回收，消耗额外的CPU资源，且堆变得过度碎片化时会直接采用serial收集方式，产生时空停顿</td></tr><tr><td align="center">G1收集器</td><td align="center">设计初衷是为了尽量缩短处理超大堆（大于 4 GB）时产生的停顿<br />Minor GC处理方式同CMS，<br />老年代空间划分为不同区域，垃圾回收处理方式为复制整理，正常情况下不易产生碎片化<br />不过仍属于concurrent收集器，会额外消耗CPU资源</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>垃圾收集器</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于编译器调优</title>
    <link href="/2020/10/09/%E7%BC%96%E8%AF%91%E5%99%A8%E8%B0%83%E4%BC%98/"/>
    <url>/2020/10/09/%E7%BC%96%E8%AF%91%E5%99%A8%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h3 id="编译器调优"><a href="#编译器调优" class="headerlink" title="编译器调优"></a>编译器调优</h3><h4 id="1-编译线程"><a href="#1-编译线程" class="headerlink" title="1.编译线程"></a>1.编译线程</h4><p>​    当方法（或者循环）适合编译时，就会进入到编译队列。队列由一个或多个后台线程处理。即编译过程是异步的，这使得代码正在编译时，程序也能持续执行。</p><p><u><strong>编译队列不严格遵守先进先出的原则</strong></u>：调用计数次数越多的方法拥有更高的优先级（保证更重要部分代码优先编译），这也是导致PrintCompilation输出中的ID为乱序的另一个原因。</p><p>不同编译器默认开启编译线程数：</p><table><thead><tr><th align="center">编译器</th><th align="center">默认开启编译线程数量</th></tr></thead><tbody><tr><td align="center">client编译器</td><td align="center">1个</td></tr><tr><td align="center">server编译器</td><td align="center">2个</td></tr><tr><td align="center"><br />分层编译</td><td align="center">默认开启多个client和server线程<br />线程数依据一个略微复杂的等式而定<br />包括目标平台CPU数取双对数之后的数值</td></tr></tbody></table><p>编译器的线程数可通过参数 <code>-XX:CICompilerCount=N</code>调整</p><h4 id="2-内联"><a href="#2-内联" class="headerlink" title="2.内联"></a>2.内联</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x, y;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span>  </span>&#123; x = i; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Point p = getPoint();<br>p.setX(p.getX() * <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>对于上述setter、getter的调用，在编译过后的代码本质上执行的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Point p = getPoint();<br>p.x = p.x * <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>这就是内联。</p><p>现在的JVM通常会使用内联代码的方式执行方法，即默认开启内联。</p><blockquote><p>“方法是否内联取决于它有多热以及它的大小。JVM 依据内部计算来判定方法是否是热点（譬如，调用很频繁）；是否是热点并不直接与任何调优参数相关。如果方法因调用频繁而可以内联，那只有在它的字节码小于 325 字节时（或 -XX:MaxFreqInlineSize=N 所设定的任意值）才会内联。否则，只有方法很小时，即小于 35 字节（或 -XX:MaxInlineSize=N 所设定的任意值）时才会内联。”</p><p>摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。” </p></blockquote><h4 id="3-逃逸分析"><a href="#3-逃逸分析" class="headerlink" title="3.逃逸分析"></a>3.逃逸分析</h4><p>在开启逃逸分析（-XX:+DoEscapeAnalysis，默认为 true）的情况下，server编译器会执行一些非常激进的优化措施。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factorial</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> BigInteger factorial;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> BigInteger <span class="hljs-title">getFactorial</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (factorial == <span class="hljs-keyword">null</span>)<br>            factorial = ...;<br>        <span class="hljs-keyword">return</span> factorial;<br>    &#125;<br>&#125;<br><br>ArrayList&lt;BigInteger&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;BigInteger&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    Factorial factorial = <span class="hljs-keyword">new</span> Factorial(i);<br>    list.add(factorial.getFactorial());<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上述代码中，factorial 对象只在循环中引用；没有任何其他代码可以访问该对象。因此，JVM 会毫不犹豫地对这个对象进行一系列优化。</p><ul><li><input disabled="" type="checkbox"> 当调用 getFactorial() 时，没必要获得同步锁。</li><li><input disabled="" type="checkbox"> 没必要在内存中保存 n；可以在寄存器中保存该值。同样，factorial 也可以保存在寄存器中。</li><li><input disabled="" type="checkbox"> 事实上，根本就不需要分配实际的 factorial 对象；可以只追踪这个对象的个别字段。</li></ul><blockquote><p>“此类优化非常复杂：虽然这个例子非常简单，但此类优化可能会伴随更复杂的代码。由于所用的代码不同，并不是所有的优化都有必要使用。但逃逸分析可以决定哪些优化是可能的，并决定编译后的代码中哪些是必要的改变。</p><p>逃逸分析默认开启。极少数情况下，它会出错，在此类情况下关闭它会变得更快或更稳定。如果你发现了这种情况，最好的应对行为就是简化相关代码：代码越简单越好。（不过如果是 bug，则应该发送报告。）”</p><p>摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于数据序列化的小结</title>
    <link href="/2020/06/09/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%B0%8F%E7%BB%93/"/>
    <url>/2020/06/09/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="关于数据序列化的小结"><a href="#关于数据序列化的小结" class="headerlink" title="关于数据序列化的小结"></a>关于数据序列化的小结</h3><p>不同系统间的数据交换可以通过基于文本的例如XML、JSON等，而在Java进程间的交换数据，通常就是通过序列化，本文为序列化相关优化总结。</p><blockquote><p>“JDK 提供了默认的序列化对象机制，以实现 Serializable 或 Externalizable 接口。实际上，默认序列化的性能还有提升的空间，但此时进行过早的优化的确不太明智。特定的序列化和反序列化代码需要很多时间编写，而且也比默认的序列化代码更难维护。编写正确的序列化代码会有一些棘手，试图优化代码也会增加出错的风险。”</p><p>摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。”  </p></blockquote><h4 id="1-transient字段"><a href="#1-transient字段" class="headerlink" title="1.transient字段"></a>1.transient字段</h4><p>​    一般情况下，对象内属性越少，序列化的性能改进代价就越小。将字段标记为transient，默认该字段就不会序列化了。</p><blockquote><p>文中代码皆引自《Java性能权威指南》</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StockPriceHistoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StockPriceHistory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String symbol;<br>    <span class="hljs-keyword">protected</span> SortedMap&lt;Date, StockPrice&gt; prices = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>    <span class="hljs-keyword">protected</span> Date firstDate;<br>    <span class="hljs-keyword">protected</span> Date lastDate;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> needsCalc = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">protected</span> BigDecimal highPrice;<br>    <span class="hljs-keyword">protected</span> BigDecimal lowPrice;<br>    <span class="hljs-keyword">protected</span> BigDecimal averagePrice;<br>    <span class="hljs-keyword">protected</span> BigDecimal stdDev;<br>    <span class="hljs-keyword">private</span> Map&lt;BigDecimal, ArrayList&lt;Date&gt;&gt; histogram;<br>    ....<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StockPriceHistoryImpl</span><span class="hljs-params">(String s, Date firstDate, Date lastDate)</span> </span>&#123;<br>        prices = ....<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    在上述代码当中，存在着一种延迟加载的情况，当构造此StockPriceHistoryImpl对象时，会创建类型为SortedMap的对象prices，而当调用字段的getter方法时 才会去计算该字段的实际值（lazy）,此类情况下，在满足业务需求的前提下，就可以给延迟加载的字段增加 transient标记 ，优化性能。</p><h4 id="2-覆盖默认的序列化"><a href="#2-覆盖默认的序列化" class="headerlink" title="2.覆盖默认的序列化"></a>2.覆盖默认的序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> y;<br>    ....<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(ObjectOutputStream oos)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        oos.defaultWriteObject();<br>        oos.writeInt(x);<br>        oos.writeInt(y);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(ObjectInputStream ois)</span></span><br><span class="hljs-function">                                <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        ois.defaultReadObject();<br>        x = ois.readInt();<br>        y = ois.readInt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>以上代码中的writeObject为序列化时调用 ， readObject为反序列化时调用</p></blockquote><p>针对不同场景，可以考虑重写方法体覆盖对应调用，以优化序列化/反序列化性能。</p><h4 id="3-压缩序列化数据"><a href="#3-压缩序列化数据" class="headerlink" title="3.压缩序列化数据"></a>3.压缩序列化数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StockPriceHistoryCompress</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">StockPriceHistory</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] zippedPrices;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> SortedMap&lt;Date, StockPrice&gt; prices;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(ObjectOutputStream out)</span></span><br><span class="hljs-function">                <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (zippedPrices == <span class="hljs-keyword">null</span>) &#123;<br>            makeZippedPrices();<br>        &#125;<br>        out.defaultWriteObject();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(ObjectInputStream in)</span></span><br><span class="hljs-function">                <span class="hljs-keyword">throws</span> IOException,  ClassNotFoundException </span>&#123;<br>        in.defaultReadObject();<br>        unzipPrices();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeZippedPrices</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        GZIPOutputStream zip = <span class="hljs-keyword">new</span> GZIPOutputStream(baos);<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<br>                <span class="hljs-keyword">new</span> BufferedOutputStream(zip));<br>        oos.writeObject(prices);<br>        oos.close();<br>        zip.close();<br>        zippedPrices = baos.toByteArray();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unzipPrices</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        ByteArrayInputStream bais = <span class="hljs-keyword">new</span> ByteArrayInputStream(zippedPrices);<br>        GZIPInputStream zip = <span class="hljs-keyword">new</span> GZIPInputStream(bais);<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<br>                <span class="hljs-keyword">new</span> BufferedInputStream(zip));<br>        prices = (SortedMap&lt;Date, StockPrice&gt;) ois.readObject();<br>        ois.close();<br>        zip.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码中示例，在数据序列化之后进行压缩处理，使得在网络中传输更快，以达到性能优化效果。</p><h4 id="4-追踪对象复制"><a href="#4-追踪对象复制" class="headerlink" title="4.追踪对象复制"></a>4.追踪对象复制</h4><p>![image-20211206150055240](/Users/xuxiuhong/Library/Application Support/typora-user-images/image-20211206150055240.png)</p><blockquote><p>上图是一个简化版本的 map。JVM 默认先序列化 Node A 的原生数据字段，然后递归调用 Node B 的 writeObject()（接着是 Node C）。Node B 也会序列化它自己的原生数据字段，然后递归序列化它上级 Node 的字段。</p><p>但是请注意——Node B 上级节点 Node A 已经被序列化，怎么办？对象序列化的代码很智能：它会意识到这一点，并且不会再次序列化 Node A 的数据。相反，它只会在先前序列化的数据中添加一个对象引用。</p><p>追踪上一级对象从而递归所有对象，会对序列化的性能有少许影响。但正如 Point 数组的例子所示，这是无法避免的：必须追踪上一级序列化的对象以便正确恢复对象引用。不过，可以通过压缩对象引用来进行智能优化，从而在对象反序列化时易于重建。</p><p>不同的集类处理这个问题的方式有所不同。比如 TreeMap，它只是遍历树然后序列化键值，丢弃了键之间的所有关系（也就是它们的排列顺序）。在反序列化时，readObject() 会重新排列数据并生成树。虽然排序对象听起来代价很昂贵，但实际并非如此：对 10 000 只股票而言，整个过程要比默认的序列化快 20%，默认机制需要追踪所有的对象引用。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES 操作简单总结</title>
    <link href="/2020/05/26/ES%20%E6%93%8D%E4%BD%9C%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/05/26/ES%20%E6%93%8D%E4%BD%9C%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="ES-操作简单总结"><a href="#ES-操作简单总结" class="headerlink" title="ES 操作简单总结"></a>ES 操作简单总结</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一 简述"></a>一 简述</h2><blockquote><p>此篇总结基于在当前最新版本(7.15.2)</p><p>ES的result API 分为不同的请求类型对应不同操作</p></blockquote><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>​    /index_name 创建/修改索引</p><p>​    /index_name/_doc/{id} 创建文档  —创建不指定id,则默认随机</p><p>POST</p><p>​    /index_name/_doc/{id} 创建/修改文档</p><p>DELETE </p><p>​    删除索引或者文档</p><p>GET</p><p>​    查询/获取文档(指定id)</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WireGuard 服务建记录</title>
    <link href="/2019/08/11/WireGuard%20%E6%9C%8D%E5%8A%A1%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/08/11/WireGuard%20%E6%9C%8D%E5%8A%A1%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="WireGuard-服务建记录"><a href="#WireGuard-服务建记录" class="headerlink" title="WireGuard 服务建记录"></a>WireGuard 服务建记录</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">系统<span class="hljs-symbol">:Debian</span> <span class="hljs-number">10</span><br>默认内核<span class="hljs-symbol">:linux-headers-</span><span class="hljs-number">4.19</span>.0<span class="hljs-number">-14</span>-amd64<br></code></pre></td></tr></table></figure><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看当前内核版本</span><br>uname -r<br><span class="hljs-meta">#</span><span class="bash"> 安装过程需要的软件包(已装跳过)</span><br>sudo apt update<br>sudo apt install apt-transport-https vim -y<br><span class="hljs-meta">#</span><span class="bash"> 搜索内核</span><br>sudo apt search linux-image<br><span class="hljs-meta">#</span><span class="bash"> 安装5.10</span><br>sudo apt-get install linux-image-5.10.0-0.bpo.9-amd64<br><span class="hljs-meta">#</span><span class="bash"> 卸载原来的内核</span><br>sudo apt-get remove linux-headers-4.19.0-14-amd64<br><span class="hljs-meta">#</span><span class="bash"> 重启</span><br>sudo reboot<br></code></pre></td></tr></table></figure><h2 id="安装WireGuard服务端"><a href="#安装WireGuard服务端" class="headerlink" title="安装WireGuard服务端"></a>安装WireGuard服务端</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 添加backports 源</span><br>sudo sh -c &quot;echo &#x27;deb https://deb.debian.org/debian buster-backports main contrib non-free&#x27; &gt; /etc/apt/sources.list.d/buster-backports.list&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 安装软件包</span><br>sudo apt update<br>sudo apt -t buster-backports install wireguard -y<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 配置服务端</span><br>cd /etc/wireguard<br>umask 077<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 生成配置需要的密钥和公钥</span></span><br>wg genkey | tee privatekey | wg pubkey &gt; publickey<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 编辑服务端配置文件 ， 内容如下</span></span><br>sudo vim /etc/wireguard/wg0.conf<br><br></code></pre></td></tr></table></figure><h3 id="服务端配置文件内容"><a href="#服务端配置文件内容" class="headerlink" title="服务端配置文件内容"></a>服务端配置文件内容</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Interface]</span><br><span class="hljs-comment"># wireguard 内网服务器地址</span><br><span class="hljs-attr">Address</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">5.1</span>/<span class="hljs-number">32</span><br><span class="hljs-attr">SaveConfig</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">PostUp</span> = iptables -A FORWARD -i wg0 -j ACCEPT<span class="hljs-comment">; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="hljs-attr">PostDown</span> = iptables -D FORWARD -i wg0 -j ACCEPT<span class="hljs-comment">; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="hljs-comment"># wireguard 监听端口</span><br><span class="hljs-attr">ListenPort</span> = <span class="hljs-number">12345</span> <br><span class="hljs-comment"># wireguard 生成的服务端密钥</span><br><span class="hljs-attr">PrivateKey</span> = KDGU6q5EG2Pv1ayJHIqAlmG2hGklF9fJ0ZGCp09GJXk=<br></code></pre></td></tr></table></figure><h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ufw allow 12345/udp<br></code></pre></td></tr></table></figure><h3 id="服务启停"><a href="#服务启停" class="headerlink" title="服务启停"></a>服务启停</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable wg-quick@wg0<br><br>sudo systemctl start wg-quick@wg0<br><br>sudo systemctl status wg-quick@wg0<br><br>sudo systemctl stop wg-quick@wg0<br></code></pre></td></tr></table></figure><h3 id="启动成功后查看"><a href="#启动成功后查看" class="headerlink" title="启动成功后查看"></a>启动成功后查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo wg<br><br>sudo ip a show wg0<br></code></pre></td></tr></table></figure><h2 id="客户端安装（Debian）"><a href="#客户端安装（Debian）" class="headerlink" title="客户端安装（Debian）"></a>客户端安装（Debian）</h2><h3 id="wireguard安装"><a href="#wireguard安装" class="headerlink" title="wireguard安装"></a>wireguard安装</h3><p>​        等同服务端软件包安装    </p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Interface]</span><br><span class="hljs-attr">PrivateKey</span> = 客户端私钥<br><span class="hljs-attr">Address</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">5.2</span>/<span class="hljs-number">32</span><br><span class="hljs-attr">DNS</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">5.1</span><br> <br><span class="hljs-section">[Peer]</span><br><span class="hljs-attr">PublicKey</span> = 服务端公钥<br><span class="hljs-attr">AllowedIPs</span> = <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">0</span><br><span class="hljs-attr">Endpoint</span> = 服务端外网ip:服务端配置监听端口<br><br></code></pre></td></tr></table></figure><h3 id="增加服务端配置"><a href="#增加服务端配置" class="headerlink" title="增加服务端配置"></a>增加服务端配置</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Peer]</span><br><span class="hljs-attr">PublicKey</span> = 客户端公钥<br><span class="hljs-attr">AllowedIPs</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">5.2</span>/<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><h2 id="Enjoy～"><a href="#Enjoy～" class="headerlink" title="Enjoy～"></a>Enjoy～</h2>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>WireGuard</tag>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux设置swap</title>
    <link href="/2018/05/26/Linux%E8%AE%BE%E7%BD%AEswap/"/>
    <url>/2018/05/26/Linux%E8%AE%BE%E7%BD%AEswap/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux设置swap"><a href="#Linux设置swap" class="headerlink" title="Linux设置swap"></a>Linux设置swap</h1><h2 id="1、创建一个-文件作为swap区"><a href="#1、创建一个-文件作为swap区" class="headerlink" title="1、创建一个 文件作为swap区"></a>1、创建一个 文件作为swap区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 名字为/swapfile1  大小为bs*count = 1024*2000000=2G，count代表的是大小，这里是2G</span><br>dd if=/dev/zero of=/swapfile1 bs=1024 count=2000000<br><br></code></pre></td></tr></table></figure><h2 id="2、将其转化为swap文件"><a href="#2、将其转化为swap文件" class="headerlink" title="2、将其转化为swap文件"></a>2、将其转化为swap文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkswap /swapfile1<br></code></pre></td></tr></table></figure><h2 id="3、将其改为只有root权限才能修改"><a href="#3、将其改为只有root权限才能修改" class="headerlink" title="3、将其改为只有root权限才能修改"></a>3、将其改为只有root权限才能修改</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> chown root:root /swapfile1</span><br><span class="hljs-meta">#</span><span class="bash"> chmod 0600 /swapfile1</span><br></code></pre></td></tr></table></figure><h2 id="4、将其激活"><a href="#4、将其激活" class="headerlink" title="4、将其激活"></a>4、将其激活</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">swapon /swapfile1<br></code></pre></td></tr></table></figure><h2 id="5、如果想要系统重启后生效，可以打开-etc-fstab在最后面加上一行"><a href="#5、如果想要系统重启后生效，可以打开-etc-fstab在最后面加上一行" class="headerlink" title="5、如果想要系统重启后生效，可以打开/etc/fstab在最后面加上一行"></a>5、如果想要系统重启后生效，可以打开/etc/fstab在最后面加上一行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano /etc/fstab<br><br>/swapfile1 swap swap defaults 0 0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>swap</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
