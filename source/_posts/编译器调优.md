
---
title: 关于编译器调优
date: 2020-10-09 17:31:56
categories:
    - 后端
tags:
    - JVM
---

### 编译器调优

#### 1.编译线程

​	当方法（或者循环）适合编译时，就会进入到编译队列。队列由一个或多个后台线程处理。即编译过程是异步的，这使得代码正在编译时，程序也能持续执行。

<u>**编译队列不严格遵守先进先出的原则**</u>：调用计数次数越多的方法拥有更高的优先级（保证更重要部分代码优先编译），这也是导致PrintCompilation输出中的ID为乱序的另一个原因。

不同编译器默认开启编译线程数：

|     编译器     |                     默认开启编译线程数量                     |
| :------------: | :----------------------------------------------------------: |
|  client编译器  |                             1个                              |
|  server编译器  |                             2个                              |
| <br />分层编译 | 默认开启多个client和server线程<br />线程数依据一个略微复杂的等式而定<br />包括目标平台CPU数取双对数之后的数值 |

编译器的线程数可通过参数 `-XX:CICompilerCount=N`调整

#### 2.内联

```java
public class Point {
    private int x, y;
    public void getX() { return x; }
    public void setX(int i)  { x = i; }
}
```

```java
Point p = getPoint();
p.setX(p.getX() * 2);
```

对于上述setter、getter的调用，在编译过后的代码本质上执行的是：

```java
Point p = getPoint();
p.x = p.x * 2;
```

这就是内联。

现在的JVM通常会使用内联代码的方式执行方法，即默认开启内联。

> “方法是否内联取决于它有多热以及它的大小。JVM 依据内部计算来判定方法是否是热点（譬如，调用很频繁）；是否是热点并不直接与任何调优参数相关。如果方法因调用频繁而可以内联，那只有在它的字节码小于 325 字节时（或 -XX:MaxFreqInlineSize=N 所设定的任意值）才会内联。否则，只有方法很小时，即小于 35 字节（或 -XX:MaxInlineSize=N 所设定的任意值）时才会内联。”
>
> 摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。” 

#### 3.逃逸分析

在开启逃逸分析（-XX:+DoEscapeAnalysis，默认为 true）的情况下，server编译器会执行一些非常激进的优化措施。

```java
public class Factorial {
    private BigInteger factorial;
    private int n;
    public Factorial(int n) {
        this.n = n;
    }
    public synchronized BigInteger getFactorial() {
        if (factorial == null)
            factorial = ...;
        return factorial;
    }
}

ArrayList<BigInteger> list = new ArrayList<BigInteger>();
for (int i = 0; i < 100; i++) {
    Factorial factorial = new Factorial(i);
    list.add(factorial.getFactorial());
}

```

在上述代码中，factorial 对象只在循环中引用；没有任何其他代码可以访问该对象。因此，JVM 会毫不犹豫地对这个对象进行一系列优化。

- [ ] 当调用 getFactorial() 时，没必要获得同步锁。
- [ ] 没必要在内存中保存 n；可以在寄存器中保存该值。同样，factorial 也可以保存在寄存器中。
- [ ] 事实上，根本就不需要分配实际的 factorial 对象；可以只追踪这个对象的个别字段。

> “此类优化非常复杂：虽然这个例子非常简单，但此类优化可能会伴随更复杂的代码。由于所用的代码不同，并不是所有的优化都有必要使用。但逃逸分析可以决定哪些优化是可能的，并决定编译后的代码中哪些是必要的改变。
>
> 逃逸分析默认开启。极少数情况下，它会出错，在此类情况下关闭它会变得更快或更稳定。如果你发现了这种情况，最好的应对行为就是简化相关代码：代码越简单越好。（不过如果是 bug，则应该发送报告。）”
>
> 摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。”