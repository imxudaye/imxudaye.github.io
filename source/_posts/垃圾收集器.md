
---
title: 关于垃圾收集器
date: 2020-10-09 17:31:56
categories:
    - 后端
tags:
    - 垃圾收集器
    - JVM
---


### 垃圾收集器

> 现代 JVM 的类型繁多，最主流的四个垃圾收集器分别是：Serial 收集器（常用于单 CPU 环境）、Throughput（或者 Parallel）收集器、Concurrent 收集器（CMS）和 G1 收集器。
>
> 

#### 1.分代收集器

> “虽然实现的细节千差万别，但所有的垃圾收集器都遵循了同一个方式，即根据情况将堆划分成不同的代（Generation）。这些代被称为“老年代”（Old Generation 或 Tenured Generation）和“新生代”（Young Generation）。新生代又被进一步地划分为不同的区段，分别称为 Eden 空间和 Survivor 空间（不过 Eden 有时会被错误地用于指代整个新生代）。”
>
> 摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。” Apple Books. 

在Java程序当中，垃圾回收大部分处理的都是临时对象，这些临时对象所在的位置就是划分的新生代区域。

新生代填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍然在使用的对象会被移动到其他地方。这种操作被称为 **Minor GC**。

在垃圾收集器回收对象整理对象时，对象的引用地址会发生改变，因此此时需确保应用线程不再继续使用这些对象，这段停顿时间被称为 **时空停顿（stop-the-world）**。通常来说，这个停顿时间对应用的性能影响最大，减少时空停顿是调优的关键考量。

当对象不断从新生代移动到老年代，最终老年代被填满之后，JVM就需要找出老年代中不再使用的对象，并对他们进行回收。简单的垃圾收集算法直接停掉所有应用线程，找出不再使用的对象，进行回收及空间整理，这个过程称为 **Full GC** ，这会导致应用程序长时间的停顿。

针对这种情况，也诞生了一些<u>无停顿的收集器</u>，例如CMS和G1收集器，此类收集器通过复杂的算法，可以在应用程序保持运行的同时找出不再使用的对象。此类收集器被称为**Concurrent收集器** 或 **低停顿收集器（Low Pause）**

|            收集器            |                             简述                             |
| :--------------------------: | :----------------------------------------------------------: |
|         Serial收集器         | 最简单的收集器，单线程，无论进行Minor GC 还是Full GC ，清理空间时，都会导致<u>时空停顿</u><br />**-XX:+UseSerialGC** |
| Throughput收集器（Parallel） | 大多数场景默认的垃圾收集器，多线程，性能明显优于serial<br />**-XX:+UseParallelGC** |
|          CMS收集器           | Minor GC会暂停应用线程，多线程回收，算法标识<br />**-XX:+UseParNewGC**<br />Full GC不再暂停应用线程，而是采用多线程定期对老年代扫描回收，消耗额外的CPU资源，且堆变得过度碎片化时会直接采用serial收集方式，产生时空停顿 |
|           G1收集器           | 设计初衷是为了尽量缩短处理超大堆（大于 4 GB）时产生的停顿<br />Minor GC处理方式同CMS，<br />老年代空间划分为不同区域，垃圾回收处理方式为复制整理，正常情况下不易产生碎片化<br />不过仍属于concurrent收集器，会额外消耗CPU资源 |

