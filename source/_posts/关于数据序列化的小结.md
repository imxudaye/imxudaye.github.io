
---
title: 关于数据序列化的小结
date: 2020-06-09 19:28:56
categories:
    - 后端
tags:
    - 序列化
---


### 关于数据序列化的小结

不同系统间的数据交换可以通过基于文本的例如XML、JSON等，而在Java进程间的交换数据，通常就是通过序列化，本文为序列化相关优化总结。

> “JDK 提供了默认的序列化对象机制，以实现 Serializable 或 Externalizable 接口。实际上，默认序列化的性能还有提升的空间，但此时进行过早的优化的确不太明智。特定的序列化和反序列化代码需要很多时间编写，而且也比默认的序列化代码更难维护。编写正确的序列化代码会有一些棘手，试图优化代码也会增加出错的风险。”
>
> 摘录来自: [美] 奥克斯（Oaks,S.）. “Java性能权威指南。”  



#### 1.transient字段

​	一般情况下，对象内属性越少，序列化的性能改进代价就越小。将字段标记为transient，默认该字段就不会序列化了。

> 文中代码皆引自《Java性能权威指南》

```java
public class StockPriceHistoryImpl implements StockPriceHistory {
    private String symbol;
    protected SortedMap<Date, StockPrice> prices = new TreeMap<>();
    protected Date firstDate;
    protected Date lastDate;
    protected boolean needsCalc = true;
    protected BigDecimal highPrice;
    protected BigDecimal lowPrice;
    protected BigDecimal averagePrice;
    protected BigDecimal stdDev;
    private Map<BigDecimal, ArrayList<Date>> histogram;
    ....
    public StockPriceHistoryImpl(String s, Date firstDate, Date lastDate) {
        prices = ....
    }
}
```

​	在上述代码当中，存在着一种延迟加载的情况，当构造此StockPriceHistoryImpl对象时，会创建类型为SortedMap的对象prices，而当调用字段的getter方法时 才会去计算该字段的实际值（lazy）,此类情况下，在满足业务需求的前提下，就可以给延迟加载的字段增加 transient标记 ，优化性能。

#### 2.覆盖默认的序列化

```java
public class Point implements Serializable {
    private transient int x;
    private transient int y;
    ....
    private void writeObject(ObjectOutputStream oos) throws IOException {
        oos.defaultWriteObject();
        oos.writeInt(x);
        oos.writeInt(y);
    }
    private void readObject(ObjectInputStream ois)
                                throws IOException, ClassNotFoundException {
        ois.defaultReadObject();
        x = ois.readInt();
        y = ois.readInt();
    }
}
```

> 以上代码中的writeObject为序列化时调用 ， readObject为反序列化时调用

针对不同场景，可以考虑重写方法体覆盖对应调用，以优化序列化/反序列化性能。



#### 3.压缩序列化数据

```java
public class StockPriceHistoryCompress
        implements StockPriceHistory, Serializable {

    private byte[] zippedPrices;
    private transient SortedMap<Date, StockPrice> prices;

    private void writeObject(ObjectOutputStream out)
                throws IOException {
        if (zippedPrices == null) {
            makeZippedPrices();
        }
        out.defaultWriteObject();
    }

    private void readObject(ObjectInputStream in)
                throws IOException,  ClassNotFoundException {
        in.defaultReadObject();
        unzipPrices();
    }

    protected void makeZippedPrices() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        GZIPOutputStream zip = new GZIPOutputStream(baos);
        ObjectOutputStream oos = new ObjectOutputStream(
                new BufferedOutputStream(zip));
        oos.writeObject(prices);
        oos.close();
        zip.close();
        zippedPrices = baos.toByteArray();
    }

    protected void unzipPrices()
                throws IOException, ClassNotFoundException {
        ByteArrayInputStream bais = new ByteArrayInputStream(zippedPrices);
        GZIPInputStream zip = new GZIPInputStream(bais);
        ObjectInputStream ois = new ObjectInputStream(
                new BufferedInputStream(zip));
        prices = (SortedMap<Date, StockPrice>) ois.readObject();
        ois.close();
        zip.close();
    }
}
```

以上代码中示例，在数据序列化之后进行压缩处理，使得在网络中传输更快，以达到性能优化效果。

#### 4.追踪对象复制

![image-20211206150055240](/Users/xuxiuhong/Library/Application Support/typora-user-images/image-20211206150055240.png)

> 上图是一个简化版本的 map。JVM 默认先序列化 Node A 的原生数据字段，然后递归调用 Node B 的 writeObject()（接着是 Node C）。Node B 也会序列化它自己的原生数据字段，然后递归序列化它上级 Node 的字段。
>
> 但是请注意——Node B 上级节点 Node A 已经被序列化，怎么办？对象序列化的代码很智能：它会意识到这一点，并且不会再次序列化 Node A 的数据。相反，它只会在先前序列化的数据中添加一个对象引用。
>
> 追踪上一级对象从而递归所有对象，会对序列化的性能有少许影响。但正如 Point 数组的例子所示，这是无法避免的：必须追踪上一级序列化的对象以便正确恢复对象引用。不过，可以通过压缩对象引用来进行智能优化，从而在对象反序列化时易于重建。
>
> 不同的集类处理这个问题的方式有所不同。比如 TreeMap，它只是遍历树然后序列化键值，丢弃了键之间的所有关系（也就是它们的排列顺序）。在反序列化时，readObject() 会重新排列数据并生成树。虽然排序对象听起来代价很昂贵，但实际并非如此：对 10 000 只股票而言，整个过程要比默认的序列化快 20%，默认机制需要追踪所有的对象引用。

